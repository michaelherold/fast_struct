# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-core` gem.
# Please instead update this file by running `bin/tapioca gem dry-core`.

# source://dry-core//lib/dry/core/constants.rb#5
module Dry
  class << self
    # source://dry-core//lib/dry/core.rb#52
    def Equalizer(*keys, **options); end

    # source://dry-types/1.7.2/lib/dry/types.rb#253
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# source://dry-core//lib/dry/core/constants.rb#6
module Dry::Core
  include ::Dry::Core::Constants

  class << self
    # source://dry-core//lib/dry/core.rb#38
    def Equalizer(*keys, **options); end

    # source://dry-core//lib/dry/core.rb#15
    def loader; end
  end
end

# source://dry-core//lib/dry/core/basic_object.rb#9
class Dry::Core::BasicObject < ::BasicObject
  # source://dry-core//lib/dry/core/basic_object.rb#32
  def class; end

  # source://dry-core//lib/dry/core/basic_object.rb#44
  def inspect; end

  def instance_of?(_arg0); end
  def is_a?(_arg0); end
  def kind_of?(_arg0); end

  # source://dry-core//lib/dry/core/basic_object.rb#101
  def object_id; end

  # source://dry-core//lib/dry/core/basic_object.rb#113
  def pretty_print(printer); end

  # source://dry-core//lib/dry/core/basic_object.rb#124
  def respond_to?(method_name, include_all = T.unsafe(nil)); end

  private

  # source://dry-core//lib/dry/core/basic_object.rb#140
  def __inspect; end

  # source://dry-core//lib/dry/core/basic_object.rb#134
  def respond_to_missing?(_method_name, _include_all); end

  class << self
    # source://dry-core//lib/dry/core/basic_object.rb#23
    def const_missing(name); end
  end
end

# source://dry-core//lib/dry/core/cache.rb#21
module Dry::Core::Cache
  # source://dry-core//lib/dry/core/cache.rb#36
  def cache; end

  # source://dry-core//lib/dry/core/cache.rb#51
  def fetch_or_store(*args, &block); end

  # source://dry-core//lib/dry/core/cache.rb#30
  def inherited(klass); end

  class << self
    # source://dry-core//lib/dry/core/cache.rb#23
    def extended(klass); end
  end
end

# source://dry-core//lib/dry/core/cache.rb#56
module Dry::Core::Cache::Methods
  # source://dry-core//lib/dry/core/cache.rb#63
  def fetch_or_store(*_arg0, **_arg1, &_arg2); end
end

# source://dry-core//lib/dry/core/class_attributes.rb#10
module Dry::Core::ClassAttributes
  include ::Dry::Core::Constants

  # source://dry-core//lib/dry/core/class_attributes.rb#68
  def defines(*args, type: T.unsafe(nil), coerce: T.unsafe(nil)); end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::Undefined = T.let(T.unsafe(nil), Object)

# source://dry-core//lib/dry/core/class_builder.rb#6
class Dry::Core::ClassBuilder
  # source://dry-core//lib/dry/core/class_builder.rb#11
  def initialize(name:, parent: T.unsafe(nil), namespace: T.unsafe(nil)); end

  # source://dry-core//lib/dry/core/class_builder.rb#35
  def call; end

  # source://dry-core//lib/dry/core/class_builder.rb#9
  def name; end

  # source://dry-core//lib/dry/core/class_builder.rb#9
  def namespace; end

  # source://dry-core//lib/dry/core/class_builder.rb#9
  def parent; end

  private

  # source://dry-core//lib/dry/core/class_builder.rb#50
  def create_anonymous; end

  # source://dry-core//lib/dry/core/class_builder.rb#81
  def create_base(namespace, name, parent); end

  # source://dry-core//lib/dry/core/class_builder.rb#64
  def create_named; end
end

# source://dry-core//lib/dry/core/class_builder.rb#7
class Dry::Core::ClassBuilder::ParentClassMismatch < ::TypeError; end

# source://dry-core//lib/dry/core/constants.rb#18
module Dry::Core::Constants
  class << self
    # source://dry-core//lib/dry/core/constants.rb#108
    def included(base); end
  end
end

# source://dry-core//lib/dry/core/constants.rb#20
Dry::Core::Constants::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core//lib/dry/core/constants.rb#22
Dry::Core::Constants::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#24
Dry::Core::Constants::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#26
Dry::Core::Constants::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core//lib/dry/core/constants.rb#28
Dry::Core::Constants::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core//lib/dry/core/constants.rb#30
Dry::Core::Constants::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#45
Dry::Core::Constants::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#43
Dry::Core::Constants::Undefined = T.let(T.unsafe(nil), Object)

# source://dry-core//lib/dry/core/container.rb#23
class Dry::Core::Container
  include ::Dry::Core::Container::Mixin::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration

  # source://dry-core//lib/dry/core/container/mixin.rb#83
  def config; end
end

# source://dry-core//lib/dry/core/container/config.rb#7
class Dry::Core::Container::Config
  # source://dry-core//lib/dry/core/container/config.rb#22
  def initialize(namespace_separator: T.unsafe(nil), resolver: T.unsafe(nil), registry: T.unsafe(nil)); end

  # source://dry-core//lib/dry/core/container/config.rb#13
  def namespace_separator; end

  # source://dry-core//lib/dry/core/container/config.rb#13
  def namespace_separator=(_arg0); end

  # source://dry-core//lib/dry/core/container/config.rb#19
  def registry; end

  # source://dry-core//lib/dry/core/container/config.rb#19
  def registry=(_arg0); end

  # source://dry-core//lib/dry/core/container/config.rb#16
  def resolver; end

  # source://dry-core//lib/dry/core/container/config.rb#16
  def resolver=(_arg0); end
end

# source://dry-core//lib/dry/core/container/config.rb#8
Dry::Core::Container::Config::DEFAULT_NAMESPACE_SEPARATOR = T.let(T.unsafe(nil), String)

# source://dry-core//lib/dry/core/container/config.rb#10
Dry::Core::Container::Config::DEFAULT_REGISTRY = T.let(T.unsafe(nil), Dry::Core::Container::Registry)

# source://dry-core//lib/dry/core/container/config.rb#9
Dry::Core::Container::Config::DEFAULT_RESOLVER = T.let(T.unsafe(nil), Dry::Core::Container::Resolver)

# source://dry-core//lib/dry/core/container/configuration.rb#7
module Dry::Core::Container::Configuration
  # source://dry-core//lib/dry/core/container/configuration.rb#25
  def config; end

  # source://dry-core//lib/dry/core/container/configuration.rb#31
  def configure; end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core//lib/dry/core/container/mixin.rb#12
class Dry::Core::Container::Error < ::StandardError; end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Container::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/container/item.rb#10
class Dry::Core::Container::Item
  # source://dry-core//lib/dry/core/container/item.rb#18
  def initialize(item, options = T.unsafe(nil)); end

  # source://dry-core//lib/dry/core/container/item.rb#26
  def call; end

  # source://dry-core//lib/dry/core/container/item.rb#36
  def callable?; end

  # source://dry-core//lib/dry/core/container/item.rb#12
  def item; end

  # source://dry-core//lib/dry/core/container/item.rb#43
  def map(func); end

  # source://dry-core//lib/dry/core/container/item.rb#15
  def options; end

  # source://dry-core//lib/dry/core/container/item.rb#31
  def value?; end
end

# source://dry-core//lib/dry/core/container/item/callable.rb#11
class Dry::Core::Container::Item::Callable < ::Dry::Core::Container::Item
  # source://dry-core//lib/dry/core/container/item/callable.rb#15
  def call; end
end

# source://dry-core//lib/dry/core/container/item/factory.rb#10
class Dry::Core::Container::Item::Factory
  # source://dry-core//lib/dry/core/container/item/factory.rb#18
  def call(item, options = T.unsafe(nil)); end
end

# source://dry-core//lib/dry/core/container/item/memoizable.rb#11
class Dry::Core::Container::Item::Memoizable < ::Dry::Core::Container::Item
  # source://dry-core//lib/dry/core/container/item/memoizable.rb#23
  def initialize(item, options = T.unsafe(nil)); end

  # source://dry-core//lib/dry/core/container/item/memoizable.rb#33
  def call; end

  # source://dry-core//lib/dry/core/container/item/memoizable.rb#13
  def memoize_mutex; end

  private

  # source://dry-core//lib/dry/core/container/item/memoizable.rb#42
  def raise_not_supported_error; end
end

# source://dry-core//lib/dry/core/container/mixin.rb#17
class Dry::Core::Container::KeyError < ::KeyError; end

# source://dry-core//lib/dry/core/container/mixin.rb#47
module Dry::Core::Container::Mixin
  mixes_in_class_methods ::Dry::Core::Container::Configuration

  # source://dry-core//lib/dry/core/container/mixin.rb#144
  def [](key); end

  # source://dry-core//lib/dry/core/container/mixin.rb#288
  def _container; end

  # source://dry-core//lib/dry/core/container/mixin.rb#300
  def clone; end

  # source://dry-core//lib/dry/core/container/mixin.rb#227
  def decorate(key, with: T.unsafe(nil), &block); end

  # source://dry-core//lib/dry/core/container/mixin.rb#293
  def dup; end

  # source://dry-core//lib/dry/core/container/mixin.rb#218
  def each(&block); end

  # source://dry-core//lib/dry/core/container/mixin.rb#201
  def each_key(&block); end

  # source://dry-core//lib/dry/core/container/stub.rb#51
  def enable_stubs!; end

  # source://dry-core//lib/dry/core/container/mixin.rb#281
  def freeze; end

  # source://dry-core//lib/dry/core/container/mixin.rb#272
  def import(namespace); end

  # source://dry-core//lib/dry/core/container/mixin.rb#181
  def key?(key); end

  # source://dry-core//lib/dry/core/container/mixin.rb#190
  def keys; end

  # source://dry-core//lib/dry/core/container/mixin.rb#158
  def merge(other, namespace: T.unsafe(nil), &block); end

  # source://dry-core//lib/dry/core/container/mixin.rb#253
  def namespace(namespace, &block); end

  # source://dry-core//lib/dry/core/container/mixin.rb#104
  def register(key, contents = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://dry-core//lib/dry/core/container/mixin.rb#131
  def resolve(key, &block); end

  class << self
    # source://dry-core//lib/dry/core/container/mixin.rb#53
    def extended(base); end

    # source://dry-core//lib/dry/core/container/mixin.rb#78
    def included(base); end
  end
end

# source://dry-core//lib/dry/core/container/mixin.rb#70
module Dry::Core::Container::Mixin::Initializer
  # source://dry-core//lib/dry/core/container/mixin.rb#71
  def initialize(*args, &block); end
end

# source://dry-core//lib/dry/core/container/mixin.rb#48
Dry::Core::Container::Mixin::PREFIX_NAMESPACE = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/container/namespace.rb#23
class Dry::Core::Container::Namespace
  # source://dry-core//lib/dry/core/container/namespace.rb#40
  def initialize(name, &block); end

  # source://dry-core//lib/dry/core/container/namespace.rb#28
  def block; end

  # source://dry-core//lib/dry/core/container/namespace.rb#25
  def name; end
end

# source://dry-core//lib/dry/core/container/namespace_dsl.rb#9
class Dry::Core::Container::NamespaceDSL < ::SimpleDelegator
  # source://dry-core//lib/dry/core/container/namespace_dsl.rb#24
  def initialize(container, namespace, namespace_separator, &block); end

  # source://dry-core//lib/dry/core/container/namespace_dsl.rb#45
  def import(namespace); end

  # source://dry-core//lib/dry/core/container/namespace_dsl.rb#41
  def namespace(namespace, &block); end

  # source://dry-core//lib/dry/core/container/namespace_dsl.rb#37
  def register(key, *args, &block); end

  # source://dry-core//lib/dry/core/container/namespace_dsl.rb#51
  def resolve(key); end

  private

  # source://dry-core//lib/dry/core/container/namespace_dsl.rb#57
  def namespaced(key); end
end

# source://dry-core//lib/dry/core/container/registry.rb#9
class Dry::Core::Container::Registry
  # source://dry-core//lib/dry/core/container/registry.rb#11
  def initialize; end

  # source://dry-core//lib/dry/core/container/registry.rb#33
  def call(container, key, item, options); end

  # source://dry-core//lib/dry/core/container/registry.rb#46
  def factory; end
end

# source://dry-core//lib/dry/core/container/resolver.rb#9
class Dry::Core::Container::Resolver
  # source://dry-core//lib/dry/core/container/resolver.rb#27
  def call(container, key); end

  # source://dry-core//lib/dry/core/container/resolver.rb#84
  def each(container, &block); end

  # source://dry-core//lib/dry/core/container/resolver.rb#69
  def each_key(container, &block); end

  # source://dry-core//lib/dry/core/container/resolver.rb#49
  def key?(container, key); end

  # source://dry-core//lib/dry/core/container/resolver.rb#58
  def keys(container); end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Container::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/container/stub.rb#6
module Dry::Core::Container::Stub
  # source://dry-core//lib/dry/core/container/stub.rb#37
  def enable_stubs!; end

  # source://dry-core//lib/dry/core/container/stub.rb#10
  def resolve(key); end

  # source://dry-core//lib/dry/core/container/stub.rb#15
  def stub(key, value, &block); end

  # source://dry-core//lib/dry/core/container/stub.rb#31
  def unstub(*keys); end

  private

  # source://dry-core//lib/dry/core/container/stub.rb#44
  def _stubs; end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Container::Undefined = T.let(T.unsafe(nil), Object)

# source://dry-core//lib/dry/core/deprecations.rb#29
module Dry::Core::Deprecations
  class << self
    # source://dry-core//lib/dry/core/deprecations.rb#115
    def [](tag); end

    # source://dry-core//lib/dry/core/deprecations.rb#51
    def announce(name, msg, tag: T.unsafe(nil), uplevel: T.unsafe(nil)); end

    # source://dry-core//lib/dry/core/deprecations.rb#68
    def deprecated_name_message(old, new = T.unsafe(nil), msg = T.unsafe(nil)); end

    # source://dry-core//lib/dry/core/deprecations.rb#60
    def deprecation_message(name, msg); end

    # source://dry-core//lib/dry/core/deprecations.rb#85
    def logger(output = T.unsafe(nil)); end

    # source://dry-core//lib/dry/core/deprecations.rb#105
    def set_logger!(output = T.unsafe(nil)); end

    # source://dry-core//lib/dry/core/deprecations.rb#39
    def warn(msg, tag: T.unsafe(nil), uplevel: T.unsafe(nil)); end
  end
end

# source://dry-core//lib/dry/core/deprecations.rb#133
module Dry::Core::Deprecations::Interface
  # source://dry-core//lib/dry/core/deprecations.rb#157
  def deprecate(old_name, new_name = T.unsafe(nil), message: T.unsafe(nil)); end

  # source://dry-core//lib/dry/core/deprecations.rb#190
  def deprecate_class_method(old_name, new_name = T.unsafe(nil), message: T.unsafe(nil)); end

  # source://dry-core//lib/dry/core/deprecations.rb#212
  def deprecate_constant(constant_name, message: T.unsafe(nil)); end

  # source://dry-core//lib/dry/core/deprecations.rb#137
  def deprecation_tag(tag = T.unsafe(nil)); end

  # source://dry-core//lib/dry/core/deprecations.rb#148
  def warn(msg); end
end

# source://dry-core//lib/dry/core/deprecations.rb#30
Dry::Core::Deprecations::STACK = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/deprecations.rb#121
class Dry::Core::Deprecations::Tagged < ::Module
  # source://dry-core//lib/dry/core/deprecations.rb#122
  def initialize(tag); end

  # source://dry-core//lib/dry/core/deprecations.rb#127
  def extended(base); end
end

# source://dry-core//lib/dry/core/descendants_tracker.rb#29
module Dry::Core::DescendantsTracker
  # source://dry-core//lib/dry/core/descendants_tracker.rb#54
  def descendants; end

  protected

  # source://dry-core//lib/dry/core/descendants_tracker.rb#59
  def add_descendant(descendant); end

  private

  # source://dry-core//lib/dry/core/descendants_tracker.rb#70
  def inherited(descendant); end

  class << self
    # source://dry-core//lib/dry/core/descendants_tracker.rb#32
    def setup(target); end

    private

    # source://dry-core//lib/dry/core/descendants_tracker.rb#39
    def extended(base); end
  end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core//lib/dry/core/equalizer.rb#6
class Dry::Core::Equalizer < ::Module
  # source://dry-core//lib/dry/core/equalizer.rb#20
  def initialize(*keys, **options); end

  private

  # source://dry-core//lib/dry/core/equalizer.rb#61
  def define_cmp_method; end

  # source://dry-core//lib/dry/core/equalizer.rb#76
  def define_hash_method(immutable:); end

  # source://dry-core//lib/dry/core/equalizer.rb#98
  def define_inspect_method; end

  # source://dry-core//lib/dry/core/equalizer.rb#50
  def define_methods(inspect: T.unsafe(nil), immutable: T.unsafe(nil)); end

  # source://dry-core//lib/dry/core/equalizer.rb#37
  def included(descendant); end
end

# source://dry-core//lib/dry/core/equalizer.rb#108
module Dry::Core::Equalizer::Methods
  # source://dry-core//lib/dry/core/equalizer.rb#135
  def ==(other); end

  # source://dry-core//lib/dry/core/equalizer.rb#120
  def eql?(other); end
end

# source://dry-core//lib/dry/core/extensions.rb#23
module Dry::Core::Extensions
  # source://dry-core//lib/dry/core/extensions.rb#43
  def available_extension?(name); end

  # source://dry-core//lib/dry/core/extensions.rb#50
  def load_extensions(*extensions); end

  # source://dry-core//lib/dry/core/extensions.rb#35
  def register_extension(name, &block); end

  class << self
    # source://dry-core//lib/dry/core/extensions.rb#25
    def extended(obj); end
  end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/inflector.rb#6
module Dry::Core::Inflector
  class << self
    # source://dry-core//lib/dry/core/inflector.rb#70
    def camelize(input); end

    # source://dry-core//lib/dry/core/inflector.rb#136
    def classify(input); end

    # source://dry-core//lib/dry/core/inflector.rb#125
    def constantize(input); end

    # source://dry-core//lib/dry/core/inflector.rb#114
    def demodulize(input); end

    # source://dry-core//lib/dry/core/inflector.rb#37
    def detect_backend; end

    # source://dry-core//lib/dry/core/inflector.rb#59
    def inflector; end

    # source://dry-core//lib/dry/core/inflector.rb#103
    def pluralize(input); end

    # source://dry-core//lib/dry/core/inflector.rb#26
    def realize_backend(path, backend_factory); end

    # source://dry-core//lib/dry/core/inflector.rb#48
    def select_backend(name = T.unsafe(nil)); end

    # source://dry-core//lib/dry/core/inflector.rb#92
    def singularize(input); end

    # source://dry-core//lib/dry/core/inflector.rb#81
    def underscore(input); end
  end
end

# source://dry-core//lib/dry/core/inflector.rb#8
Dry::Core::Inflector::BACKENDS = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/errors.rb#5
class Dry::Core::InvalidClassAttributeValueError < ::StandardError
  # source://dry-core//lib/dry/core/errors.rb#6
  def initialize(name, value); end
end

# source://dry-core//lib/dry/core/memoizable.rb#5
module Dry::Core::Memoizable
  mixes_in_class_methods ::Dry::Core::Memoizable::ClassInterface::Object

  class << self
    # source://dry-core//lib/dry/core/memoizable.rb#48
    def included(klass); end
  end
end

# source://dry-core//lib/dry/core/memoizable.rb#9
module Dry::Core::Memoizable::ClassInterface; end

# source://dry-core//lib/dry/core/memoizable.rb#10
module Dry::Core::Memoizable::ClassInterface::Base
  # source://dry-core//lib/dry/core/memoizable.rb#15
  def inherited(base); end

  # source://dry-core//lib/dry/core/memoizable.rb#11
  def memoize(*names); end
end

# source://dry-core//lib/dry/core/memoizable.rb#23
module Dry::Core::Memoizable::ClassInterface::BasicObject
  include ::Dry::Core::Memoizable::ClassInterface::Base

  # source://dry-core//lib/dry/core/memoizable.rb#26
  def new(*_arg0); end
end

# source://dry-core//lib/dry/core/memoizable.rb#33
module Dry::Core::Memoizable::ClassInterface::Object
  include ::Dry::Core::Memoizable::ClassInterface::Base

  # source://dry-core//lib/dry/core/memoizable.rb#36
  def new(*_arg0, **_arg1); end
end

# source://dry-core//lib/dry/core/memoizable.rb#6
Dry::Core::Memoizable::MEMOIZED_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/memoizable.rb#59
class Dry::Core::Memoizable::Memoizer < ::Module
  # source://dry-core//lib/dry/core/memoizable.rb#67
  def initialize(klass, names); end

  private

  # source://dry-core//lib/dry/core/memoizable.rb#160
  def declaration(definition, lookup); end

  # source://dry-core//lib/dry/core/memoizable.rb#81
  def define_memoizable(method:); end

  # source://dry-core//lib/dry/core/memoizable.rb#192
  def make_bind_name(idx); end

  # source://dry-core//lib/dry/core/memoizable.rb#197
  def map_bind_type(type, name, original_params, defined_types); end

  # source://dry-core//lib/dry/core/memoizable.rb#183
  def name_from_param(name); end

  # source://dry-core//lib/dry/core/memoizable.rb#229
  def param(name, type); end
end

# source://dry-core//lib/dry/core/memoizable.rb#60
Dry::Core::Memoizable::Memoizer::KERNEL = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/memoizable.rb#7
Dry::Core::Memoizable::PARAM_PLACEHOLDERS = T.let(T.unsafe(nil), Array)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::Undefined = T.let(T.unsafe(nil), Object)

# source://dry-core//lib/dry/core/version.rb#5
Dry::Core::VERSION = T.let(T.unsafe(nil), String)

module Dry::Types
  extend ::Dry::Core::Constants

  class << self
    # source://dry-types/1.7.2/lib/dry/types/constraints.rb#13
    def Rule(options); end

    # source://dry-types/1.7.2/lib/dry/types.rb#115
    def [](name); end

    # source://dry-types/1.7.2/lib/dry/types.rb#163
    def const_missing(const); end

    # source://dry-types/1.7.2/lib/dry/types.rb#82
    def container; end

    # source://dry-types/1.7.2/lib/dry/types.rb#197
    def define_builder(method, &block); end

    # source://dry-types/1.7.2/lib/dry/types.rb#149
    def identifier(klass); end

    # source://dry-types/1.7.2/lib/dry/types.rb#73
    def included(*_arg0); end

    # source://dry-types/1.7.2/lib/dry/types.rb#33
    def loader; end

    # source://dry-core//lib/dry/core/deprecations.rb#202
    def module(*args, &block); end

    # source://dry-types/1.7.2/lib/dry/types.rb#104
    def register(name, type = T.unsafe(nil), &block); end

    # source://dry-types/1.7.2/lib/dry/types.rb#91
    def registered?(class_or_identifier); end

    # source://dry-types/1.7.2/lib/dry/types/constraints.rb#26
    def rule_compiler; end

    # source://dry-types/1.7.2/lib/dry/types.rb#158
    def type_map; end
  end
end

class Dry::Types::Compiler
  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#11
  def initialize(registry); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#15
  def call(ast); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#116
  def compile_fn(fn); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#9
  def registry; end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#19
  def visit(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#112
  def visit_any(meta); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#61
  def visit_array(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#24
  def visit_constrained(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#30
  def visit_constructor(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#102
  def visit_enum(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#67
  def visit_hash(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#82
  def visit_json_array(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#77
  def visit_json_hash(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#97
  def visit_key(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#36
  def visit_lax(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#107
  def visit_map(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#41
  def visit_nominal(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#92
  def visit_params_array(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#87
  def visit_params_hash(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#52
  def visit_rule(node); end

  # source://dry-core//lib/dry/core/deprecations.rb#168
  def visit_safe(*args, &block); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#72
  def visit_schema(node); end

  # source://dry-types/1.7.2/lib/dry/types/compiler.rb#56
  def visit_sum(node); end
end

class Dry::Types::Container
  # source://dry-core//lib/dry/core/container/mixin.rb#83
  def config; end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::Self = T.let(T.unsafe(nil), Proc)

module Dry::Types::Type
  # source://dry-types/1.7.2/lib/dry/types/type.rb#18
  def ===(input = T.unsafe(nil)); end

  # source://dry-types/1.7.2/lib/dry/types/type.rb#43
  def [](input = T.unsafe(nil), &block); end

  # source://dry-types/1.7.2/lib/dry/types/type.rb#43
  def call(input = T.unsafe(nil), &block); end

  # source://dry-core//lib/dry/core/deprecations.rb#168
  def safe(*args, &block); end

  # source://dry-types/1.7.2/lib/dry/types/type.rb#18
  def valid?(input = T.unsafe(nil)); end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::Undefined = T.let(T.unsafe(nil), Object)
