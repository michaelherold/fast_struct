# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-types` gem.
# Please instead update this file by running `bin/tapioca gem dry-types`.

# source://dry-types//lib/dry/types/constraints.rb#3
module Dry
  class << self
    # source://dry-core/1.0.1/lib/dry/core.rb#52
    def Equalizer(*keys, **options); end

    # source://dry-types//lib/dry/types.rb#253
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# source://dry-types//lib/dry/types/constraints.rb#7
module Dry::Types
  include ::Dry::Core::Constants
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::Dry::Core::Extensions
  extend ::Dry::Core::Deprecations::Interface

  class << self
    # source://dry-types//lib/dry/types/constraints.rb#13
    def Rule(options); end

    # source://dry-types//lib/dry/types.rb#115
    def [](name); end

    # source://dry-types//lib/dry/types.rb#163
    def const_missing(const); end

    # source://dry-types//lib/dry/types.rb#82
    def container; end

    # source://dry-types//lib/dry/types.rb#197
    def define_builder(method, &block); end

    # source://dry-types//lib/dry/types.rb#149
    def identifier(klass); end

    # source://dry-types//lib/dry/types.rb#73
    def included(*_arg0); end

    # source://dry-types//lib/dry/types.rb#33
    def loader; end

    # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#202
    def module(*args, &block); end

    # source://dry-types//lib/dry/types.rb#104
    def register(name, type = T.unsafe(nil), &block); end

    # source://dry-types//lib/dry/types.rb#91
    def registered?(class_or_identifier); end

    # source://dry-types//lib/dry/types/constraints.rb#26
    def rule_compiler; end

    # source://dry-types//lib/dry/types.rb#158
    def type_map; end
  end
end

# source://dry-types//lib/dry/types/core.rb#38
Dry::Types::ALL_PRIMITIVES = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/any.rb#45
Dry::Types::Any = T.let(T.unsafe(nil), Dry::Types::AnyClass)

# source://dry-types//lib/dry/types/any.rb#11
class Dry::Types::AnyClass < ::Dry::Types::Nominal
  # source://dry-types//lib/dry/types/any.rb#17
  def initialize(**options); end

  # source://dry-types//lib/dry/types/any.rb#24
  def name; end

  # source://dry-types//lib/dry/types/any.rb#40
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/any.rb#33
  def with(**new_options); end

  class << self
    # source://dry-types//lib/dry/types/any.rb#12
    def name; end
  end
end

# source://dry-types//lib/dry/types/array.rb#8
class Dry::Types::Array < ::Dry::Types::Nominal
  # source://dry-types//lib/dry/types/array.rb#27
  def constructor_type; end

  # source://dry-types//lib/dry/types/array.rb#16
  def of(type); end
end

# source://dry-types//lib/dry/types/array/constructor.rb#8
class Dry::Types::Array::Constructor < ::Dry::Types::Constructor
  # source://dry-types//lib/dry/types/array/constructor.rb#10
  def constructor_type; end

  # source://dry-types//lib/dry/types/array/constructor.rb#17
  def lax; end

  # source://dry-types//lib/dry/types/array/constructor.rb#24
  def of(member); end
end

# source://dry-types//lib/dry/types/array/member.rb#9
class Dry::Types::Array::Member < ::Dry::Types::Array
  # source://dry-types//lib/dry/types/array/member.rb#19
  def initialize(primitive, **options); end

  # source://dry-types//lib/dry/types/array/member.rb#45
  def call_safe(input); end

  # source://dry-types//lib/dry/types/array/member.rb#29
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/array/member.rb#116
  def constructor_type; end

  # source://dry-types//lib/dry/types/array/member.rb#100
  def lax; end

  # source://dry-types//lib/dry/types/array/member.rb#11
  def member; end

  # source://dry-types//lib/dry/types/array/member.rb#107
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/array/member.rb#73
  def try(input, &block); end
end

# source://dry-types//lib/dry/types/builder.rb#9
module Dry::Types::Builder
  include ::Dry::Core::Constants

  # source://dry-types//lib/dry/types/builder.rb#44
  def &(other); end

  # source://dry-types//lib/dry/types/builder.rb#153
  def <<(constructor = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/builder.rb#55
  def >(other); end

  # source://dry-types//lib/dry/types/builder.rb#153
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/builder.rb#153
  def append(constructor = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/builder.rb#75
  def constrained(options); end

  # source://dry-types//lib/dry/types/builder.rb#15
  def constrained_type; end

  # source://dry-types//lib/dry/types/builder.rb#153
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/builder.rb#22
  def constructor_type; end

  # source://dry-types//lib/dry/types/builder.rb#90
  def default(input = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://dry-types//lib/dry/types/builder.rb#123
  def enum(*values); end

  # source://dry-types//lib/dry/types/builder.rb#170
  def fallback(value = T.unsafe(nil), shared: T.unsafe(nil), &_fallback); end

  # source://dry-types//lib/dry/types/builder.rb#140
  def lax; end

  # source://dry-types//lib/dry/types/builder.rb#64
  def optional; end

  # source://dry-types//lib/dry/types/builder.rb#153
  def prepend(constructor = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/builder.rb#33
  def |(other); end

  private

  # source://dry-types//lib/dry/types/builder.rb#208
  def compose(other, composition_class); end
end

# source://dry-types//lib/dry/types/builder_methods.rb#9
module Dry::Types::BuilderMethods
  # source://dry-types//lib/dry/types/builder_methods.rb#26
  def Array(type); end

  # source://dry-types//lib/dry/types/builder_methods.rb#71
  def Constant(object); end

  # source://dry-types//lib/dry/types/builder_methods.rb#83
  def Constructor(klass, cons = T.unsafe(nil), &block); end

  # source://dry-types//lib/dry/types/builder_methods.rb#35
  def Hash(type_map); end

  # source://dry-types//lib/dry/types/builder_methods.rb#50
  def Instance(klass); end

  # source://dry-types//lib/dry/types/builder_methods.rb#134
  def Interface(*methods); end

  # source://dry-types//lib/dry/types/builder_methods.rb#120
  def Map(key_type, value_type); end

  # source://dry-types//lib/dry/types/builder_methods.rb#100
  def Nominal(klass); end

  # source://dry-types//lib/dry/types/builder_methods.rb#50
  def Strict(klass); end

  # source://dry-types//lib/dry/types/builder_methods.rb#61
  def Value(value); end

  # source://dry-types//lib/dry/types/builder_methods.rb#11
  def included(base); end
end

# source://dry-types//lib/dry/types/core.rb#41
Dry::Types::COERCIBLE = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/errors.rb#15
class Dry::Types::CoercionError < ::StandardError
  # source://dry-types//lib/dry/types/errors.rb#35
  def initialize(message, meta: T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/errors.rb#32
  def meta; end

  class << self
    # source://dry-types//lib/dry/types/errors.rb#17
    def handle(exception, meta: T.unsafe(nil)); end
  end
end

# source://dry-types//lib/dry/types/coercions.rb#8
module Dry::Types::Coercions
  include ::Dry::Core::Constants

  # source://dry-types//lib/dry/types/coercions.rb#18
  def to_date(input, &block); end

  # source://dry-types//lib/dry/types/coercions.rb#41
  def to_date_time(input, &block); end

  # source://dry-types//lib/dry/types/coercions.rb#87
  def to_symbol(input, &block); end

  # source://dry-types//lib/dry/types/coercions.rb#64
  def to_time(input, &block); end

  private

  # source://dry-types//lib/dry/types/coercions.rb#102
  def empty_str?(value); end
end

# source://dry-types//lib/dry/types/coercions/json.rb#14
module Dry::Types::Coercions::JSON
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # source://dry-types//lib/dry/types/coercions/json.rb#41
    def to_decimal(input, &_block); end

    # source://dry-types//lib/dry/types/coercions/json.rb#24
    def to_nil(input, &_block); end
  end
end

# source://dry-types//lib/dry/types/coercions/params.rb#12
module Dry::Types::Coercions::Params
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # source://dry-types//lib/dry/types/coercions/params.rb#135
    def to_ary(input, &_block); end

    # source://dry-types//lib/dry/types/coercions/params.rb#116
    def to_decimal(input, &_block); end

    # source://dry-types//lib/dry/types/coercions/params.rb#69
    def to_false(input, &_block); end

    # source://dry-types//lib/dry/types/coercions/params.rb#103
    def to_float(input, &block); end

    # source://dry-types//lib/dry/types/coercions/params.rb#154
    def to_hash(input, &_block); end

    # source://dry-types//lib/dry/types/coercions/params.rb#86
    def to_int(input, &block); end

    # source://dry-types//lib/dry/types/coercions/params.rb#29
    def to_nil(input, &_block); end

    # source://dry-types//lib/dry/types/coercions/params.rb#49
    def to_true(input, &_block); end
  end
end

# source://dry-types//lib/dry/types/coercions/params.rb#15
Dry::Types::Coercions::Params::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/coercions/params.rb#14
Dry::Types::Coercions::Params::FALSE_VALUES = T.let(T.unsafe(nil), Array)

# source://dry-types//lib/dry/types/coercions/params.rb#13
Dry::Types::Coercions::Params::TRUE_VALUES = T.let(T.unsafe(nil), Array)

# source://dry-types//lib/dry/types/compiler.rb#6
class Dry::Types::Compiler
  extend ::Dry::Core::Deprecations::Interface

  # source://dry-types//lib/dry/types/compiler.rb#11
  def initialize(registry); end

  # source://dry-types//lib/dry/types/compiler.rb#15
  def call(ast); end

  # source://dry-types//lib/dry/types/compiler.rb#116
  def compile_fn(fn); end

  # source://dry-types//lib/dry/types/compiler.rb#9
  def registry; end

  # source://dry-types//lib/dry/types/compiler.rb#19
  def visit(node); end

  # source://dry-types//lib/dry/types/compiler.rb#112
  def visit_any(meta); end

  # source://dry-types//lib/dry/types/compiler.rb#61
  def visit_array(node); end

  # source://dry-types//lib/dry/types/compiler.rb#24
  def visit_constrained(node); end

  # source://dry-types//lib/dry/types/compiler.rb#30
  def visit_constructor(node); end

  # source://dry-types//lib/dry/types/compiler.rb#102
  def visit_enum(node); end

  # source://dry-types//lib/dry/types/compiler.rb#67
  def visit_hash(node); end

  # source://dry-types//lib/dry/types/compiler.rb#82
  def visit_json_array(node); end

  # source://dry-types//lib/dry/types/compiler.rb#77
  def visit_json_hash(node); end

  # source://dry-types//lib/dry/types/compiler.rb#97
  def visit_key(node); end

  # source://dry-types//lib/dry/types/compiler.rb#36
  def visit_lax(node); end

  # source://dry-types//lib/dry/types/compiler.rb#107
  def visit_map(node); end

  # source://dry-types//lib/dry/types/compiler.rb#41
  def visit_nominal(node); end

  # source://dry-types//lib/dry/types/compiler.rb#92
  def visit_params_array(node); end

  # source://dry-types//lib/dry/types/compiler.rb#87
  def visit_params_hash(node); end

  # source://dry-types//lib/dry/types/compiler.rb#52
  def visit_rule(node); end

  # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#168
  def visit_safe(*args, &block); end

  # source://dry-types//lib/dry/types/compiler.rb#72
  def visit_schema(node); end

  # source://dry-types//lib/dry/types/compiler.rb#56
  def visit_sum(node); end
end

# source://dry-types//lib/dry/types/composition.rb#9
module Dry::Types::Composition
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition::Constrained

  # source://dry-types//lib/dry/types/composition.rb#46
  def initialize(left, right, **options); end

  # source://dry-types//lib/dry/types/composition.rb#94
  def call_safe(input, &block); end

  # source://dry-types//lib/dry/types/composition.rb#85
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/composition.rb#69
  def constrained?; end

  # source://dry-types//lib/dry/types/composition.rb#62
  def default?; end

  # source://dry-types//lib/dry/types/composition.rb#116
  def failure(input, _error = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/composition.rb#18
  def left; end

  # source://dry-types//lib/dry/types/composition.rb#55
  def name; end

  # source://dry-types//lib/dry/types/composition.rb#76
  def optional?; end

  # source://dry-types//lib/dry/types/composition.rb#130
  def primitive?(value); end

  # source://dry-types//lib/dry/types/composition.rb#21
  def right; end

  # source://dry-types//lib/dry/types/composition.rb#106
  def success(input); end

  # source://dry-types//lib/dry/types/composition.rb#137
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/composition.rb#147
  def to_proc; end

  # source://dry-types//lib/dry/types/composition.rb#101
  def try(input); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#33
    def included(base); end
  end
end

# source://dry-types//lib/dry/types/composition.rb#23
module Dry::Types::Composition::Constrained
  # source://dry-types//lib/dry/types/composition.rb#28
  def constrained?; end

  # source://dry-types//lib/dry/types/composition.rb#24
  def rule; end
end

# source://dry-types//lib/dry/types/constrained.rb#8
class Dry::Types::Constrained
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # source://dry-types//lib/dry/types/constrained.rb#23
  def initialize(type, **options); end

  # source://dry-types//lib/dry/types/constrained.rb#103
  def ===(value); end

  # source://dry-types//lib/dry/types/constrained.rb#44
  def call_safe(input, &block); end

  # source://dry-types//lib/dry/types/constrained.rb#31
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/constrained.rb#87
  def constrained(options); end

  # source://dry-types//lib/dry/types/constrained.rb#94
  def constrained?; end

  # source://dry-types//lib/dry/types/constrained.rb#122
  def constructor_type; end

  # source://dry-types//lib/dry/types/constrained.rb#111
  def lax; end

  # source://dry-types//lib/dry/types/constrained.rb#16
  def rule; end

  # source://dry-types//lib/dry/types/constrained.rb#117
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/constrained.rb#67
  def try(input, &block); end

  private

  # source://dry-types//lib/dry/types/constrained.rb#133
  def decorate?(response); end
end

# source://dry-types//lib/dry/types/constrained/coercible.rb#9
class Dry::Types::Constrained::Coercible < ::Dry::Types::Constrained
  # source://dry-types//lib/dry/types/constrained/coercible.rb#27
  def call_safe(input); end

  # source://dry-types//lib/dry/types/constrained/coercible.rb#13
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/constrained/coercible.rb#40
  def try(input, &block); end
end

# source://dry-types//lib/dry/types/errors.rb#116
class Dry::Types::ConstraintError < ::Dry::Types::CoercionError
  # source://dry-types//lib/dry/types/errors.rb#124
  def initialize(result, input); end

  # source://dry-types//lib/dry/types/errors.rb#120
  def input; end

  # source://dry-types//lib/dry/types/errors.rb#136
  def message; end

  # source://dry-types//lib/dry/types/errors.rb#118
  def result; end

  # source://dry-types//lib/dry/types/errors.rb#136
  def to_s; end
end

# source://dry-types//lib/dry/types/constructor.rb#9
class Dry::Types::Constructor < ::Dry::Types::Nominal
  # source://dry-types//lib/dry/types/constructor.rb#62
  def initialize(type, fn: T.unsafe(nil), **options); end

  # source://dry-types//lib/dry/types/constructor.rb#144
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/constructor.rb#109
  def >>(new_fn = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/constructor.rb#109
  def append(new_fn = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/constructor.rb#72
  def call_safe(input); end

  # source://dry-types//lib/dry/types/constructor.rb#80
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/constructor.rb#124
  def constrained_type; end

  # source://dry-types//lib/dry/types/constructor.rb#109
  def constructor(new_fn = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/constructor.rb#13
  def fn; end

  # source://dry-types//lib/dry/types/constructor.rb#153
  def lax; end

  # source://dry-types//lib/dry/types/constructor.rb#144
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/constructor.rb#131
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/constructor.rb#162
  def to_proc; end

  # source://dry-types//lib/dry/types/constructor.rb#91
  def try(input, &block); end

  # source://dry-types//lib/dry/types/constructor.rb#16
  def type; end

  private

  # source://dry-types//lib/dry/types/constructor.rb#184
  def method_missing(method, *args, &block); end

  # source://dry-types//lib/dry/types/constructor.rb#173
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end

  class << self
    # source://dry-types//lib/dry/types/constructor.rb#35
    def [](type, fn:, **options); end

    # source://dry-types//lib/dry/types/constructor.rb#25
    def new(input, fn: T.unsafe(nil), **options, &block); end

    # source://dry-types//lib/dry/types/constructor.rb#46
    def wrapper_type; end
  end
end

# source://dry-types//lib/dry/types/constructor/function.rb#11
class Dry::Types::Constructor::Function
  include ::Dry::Core::Equalizer::Methods

  # source://dry-types//lib/dry/types/constructor/function.rb#173
  def initialize(fn); end

  # source://dry-types//lib/dry/types/constructor/function.rb#208
  def <<(other); end

  # source://dry-types//lib/dry/types/constructor/function.rb#202
  def >>(other); end

  # source://dry-types//lib/dry/types/constructor/function.rb#178
  def [](input, &block); end

  # source://dry-types//lib/dry/types/constructor/function.rb#184
  def arity; end

  # source://dry-types//lib/dry/types/constructor/function.rb#178
  def call(input, &block); end

  # source://dry-types//lib/dry/types/constructor/function.rb#171
  def fn; end

  # source://dry-types//lib/dry/types/constructor/function.rb#193
  def to_ast; end

  # source://dry-types//lib/dry/types/constructor/function.rb#188
  def wrapper?; end

  class << self
    # source://dry-types//lib/dry/types/constructor/function.rb#141
    def [](fn); end

    # source://dry-types//lib/dry/types/constructor/function.rb#158
    def yields_block?(fn); end
  end
end

# source://dry-types//lib/dry/types/constructor/function.rb#26
class Dry::Types::Constructor::Function::MethodCall < ::Dry::Types::Constructor::Function
  # source://dry-types//lib/dry/types/constructor/function.rb#112
  def initialize(fn); end

  # source://dry-types//lib/dry/types/constructor/function.rb#110
  def name; end

  # source://dry-types//lib/dry/types/constructor/function.rb#110
  def target; end

  # source://dry-types//lib/dry/types/constructor/function.rb#118
  def to_ast; end

  class << self
    # source://dry-types//lib/dry/types/constructor/function.rb#105
    def [](fn, safe); end

    # source://dry-types//lib/dry/types/constructor/function.rb#32
    def call_class(method, public, safe); end
  end
end

# source://dry-types//lib/dry/types/constructor/function.rb#85
class Dry::Types::Constructor::Function::MethodCall::PrivateCall < ::Dry::Types::Constructor::Function::MethodCall
  # source://dry-types//lib/dry/types/constructor/function.rb#86
  def call(input, &block); end
end

# source://dry-types//lib/dry/types/constructor/function.rb#94
class Dry::Types::Constructor::Function::MethodCall::PrivateSafeCall < ::Dry::Types::Constructor::Function::MethodCall::PrivateCall
  # source://dry-types//lib/dry/types/constructor/function.rb#95
  def call(input, &block); end
end

# source://dry-types//lib/dry/types/constructor/function.rb#53
class Dry::Types::Constructor::Function::MethodCall::PublicCall < ::Dry::Types::Constructor::Function::MethodCall
  class << self
    # source://dry-types//lib/dry/types/constructor/function.rb#59
    def call_interface(method, safe); end
  end
end

# source://dry-types//lib/dry/types/constructor/function.rb#15
class Dry::Types::Constructor::Function::Safe < ::Dry::Types::Constructor::Function
  # source://dry-types//lib/dry/types/constructor/function.rb#16
  def call(input, &block); end
end

# source://dry-types//lib/dry/types/constructor/function.rb#123
class Dry::Types::Constructor::Function::Wrapper < ::Dry::Types::Constructor::Function
  # source://dry-types//lib/dry/types/constructor/function.rb#125
  def [](input, type, &block); end

  # source://dry-types//lib/dry/types/constructor/function.rb#132
  def arity; end

  # source://dry-types//lib/dry/types/constructor/function.rb#125
  def call(input, type, &block); end
end

# source://dry-types//lib/dry/types/constructor/wrapper.rb#7
module Dry::Types::Constructor::Wrapper
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#60
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/builder.rb#153
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/builder.rb#153
  def append(constructor = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/constructor/wrapper.rb#11
  def call_safe(input, &block); end

  # source://dry-types//lib/dry/types/constructor/wrapper.rb#18
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/builder.rb#153
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/constructor/wrapper.rb#77
  def lax; end

  # source://dry-types//lib/dry/types/constructor/wrapper.rb#60
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # source://dry-types//lib/dry/types/constructor/wrapper.rb#29
  def try(input, &block); end

  private

  # source://dry-types//lib/dry/types/constructor/wrapper.rb#88
  def __new__(type); end
end

# source://dry-types//lib/dry/types/container.rb#8
class Dry::Types::Container
  include ::Dry::Core::Container::Mixin::Initializer
  include ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration

  # source://dry-core/1.0.1/lib/dry/core/container/mixin.rb#83
  def config; end
end

# source://dry-types//lib/dry/types/decorator.rb#8
module Dry::Types::Decorator
  include ::Dry::Types::Options

  # source://dry-types//lib/dry/types/decorator.rb#15
  def initialize(type, *_arg1, **_arg2); end

  # source://dry-types//lib/dry/types/decorator.rb#41
  def constrained?; end

  # source://dry-types//lib/dry/types/decorator.rb#34
  def default?; end

  # source://dry-types//lib/dry/types/decorator.rb#60
  def to_proc; end

  # source://dry-types//lib/dry/types/decorator.rb#27
  def try(input, &block); end

  # source://dry-types//lib/dry/types/decorator.rb#12
  def type; end

  private

  # source://dry-types//lib/dry/types/decorator.rb#100
  def __new__(type); end

  # source://dry-types//lib/dry/types/decorator.rb#71
  def decorate?(response); end

  # source://dry-types//lib/dry/types/decorator.rb#82
  def method_missing(meth, *args, **_arg2, &block); end

  # source://dry-types//lib/dry/types/decorator.rb#51
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# source://dry-types//lib/dry/types/default.rb#8
class Dry::Types::Default
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # source://dry-types//lib/dry/types/default.rb#53
  def initialize(type, value, **_arg2); end

  # source://dry-types//lib/dry/types/default.rb#110
  def call_safe(input = T.unsafe(nil), &block); end

  # source://dry-types//lib/dry/types/default.rb#97
  def call_unsafe(input = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/default.rb#121
  def callable?; end

  # source://dry-types//lib/dry/types/default.rb#65
  def constrained(*_arg0, **_arg1, &_arg2); end

  # source://dry-types//lib/dry/types/default.rb#72
  def default?; end

  # source://dry-types//lib/dry/types/default.rb#32
  def evaluate; end

  # source://dry-types//lib/dry/types/default.rb#81
  def try(input); end

  # source://dry-types//lib/dry/types/default.rb#88
  def valid?(value = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/default.rb#32
  def value; end

  class << self
    # source://dry-types//lib/dry/types/default.rb#41
    def [](value); end
  end
end

# source://dry-types//lib/dry/types/default.rb#10
class Dry::Types::Default::Callable < ::Dry::Types::Default
  # source://dry-types//lib/dry/types/default.rb#20
  def callable?; end

  # source://dry-types//lib/dry/types/default.rb#15
  def evaluate; end
end

Dry::Types::Definition = Dry::Types::Nominal

# source://dry-types//lib/dry/types/enum.rb#8
class Dry::Types::Enum
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder

  # source://dry-types//lib/dry/types/enum.rb#28
  def initialize(type, **options); end

  # source://dry-types//lib/dry/types/enum.rb#46
  def call_safe(input, &block); end

  # source://dry-types//lib/dry/types/enum.rb#39
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/enum.rb#58
  def default(*_arg0); end

  # source://dry-types//lib/dry/types/type.rb#18
  def include?(input = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/enum.rb#76
  def inspect; end

  # source://dry-types//lib/dry/types/enum.rb#21
  def inverted_mapping; end

  # source://dry-types//lib/dry/types/enum.rb#18
  def mapping; end

  # source://dry-types//lib/dry/types/enum.rb#69
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/enum.rb#76
  def to_s; end

  # source://dry-types//lib/dry/types/enum.rb#53
  def try(input); end

  # source://dry-types//lib/dry/types/enum.rb#15
  def values; end

  private

  # source://dry-types//lib/dry/types/enum.rb#90
  def map_value(input); end
end

# source://dry-types//lib/dry/types/fn_container.rb#8
class Dry::Types::FnContainer
  class << self
    # source://dry-types//lib/dry/types/fn_container.rb#23
    def [](fn_name); end

    # source://dry-types//lib/dry/types/fn_container.rb#10
    def container; end

    # source://dry-types//lib/dry/types/fn_container.rb#15
    def register(function = T.unsafe(nil), &block); end

    # source://dry-types//lib/dry/types/fn_container.rb#32
    def register_name(function); end
  end
end

# source://dry-types//lib/dry/types/hash.rb#8
class Dry::Types::Hash < ::Dry::Types::Nominal
  # source://dry-types//lib/dry/types/hash.rb#77
  def constructor_type; end

  # source://dry-types//lib/dry/types/hash.rb#40
  def map(key_type, value_type); end

  # source://dry-types//lib/dry/types/hash.rb#50
  def permissive(*_arg0); end

  # source://dry-types//lib/dry/types/hash.rb#22
  def schema(keys_or_map, meta = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/hash.rb#50
  def strict(*_arg0); end

  # source://dry-types//lib/dry/types/hash.rb#50
  def strict_with_defaults(*_arg0); end

  # source://dry-types//lib/dry/types/hash.rb#50
  def symbolized(*_arg0); end

  # source://dry-types//lib/dry/types/hash.rb#95
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/hash.rb#86
  def transform_types?; end

  # source://dry-types//lib/dry/types/hash.rb#50
  def weak(*_arg0); end

  # source://dry-types//lib/dry/types/hash.rb#67
  def with_type_transform(proc = T.unsafe(nil), &block); end

  private

  # source://dry-types//lib/dry/types/hash.rb#102
  def build_keys(type_map); end

  # source://dry-types//lib/dry/types/hash.rb#123
  def key_name(key); end

  # source://dry-types//lib/dry/types/hash.rb#114
  def resolve_type(type); end
end

# source://dry-types//lib/dry/types/hash/constructor.rb#9
class Dry::Types::Hash::Constructor < ::Dry::Types::Constructor
  # source://dry-types//lib/dry/types/hash/constructor.rb#11
  def constructor_type; end

  # source://dry-types//lib/dry/types/hash/constructor.rb#18
  def lax; end

  # source://dry-types//lib/dry/types/hash/constructor.rb#25
  def schema(*_arg0, **_arg1, &_arg2); end
end

# source://dry-types//lib/dry/types/hash.rb#9
Dry::Types::Hash::NOT_REQUIRED = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/implication.rb#8
class Dry::Types::Implication
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition

  # source://dry-types//lib/dry/types/implication.rb#33
  def call_safe(input, &block); end

  # source://dry-types//lib/dry/types/implication.rb#20
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/implication.rb#57
  def primitive?(value); end

  # source://dry-types//lib/dry/types/implication.rb#44
  def try(input); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#36
    def ast_type; end

    # source://dry-types//lib/dry/types/composition.rb#37
    def composition_name; end

    # source://dry-types//lib/dry/types/implication.rb#11
    def operator; end
  end
end

# source://dry-types//lib/dry/types/implication.rb#0
class Dry::Types::Implication::Constrained < ::Dry::Types::Implication
  include ::Dry::Types::Composition::Constrained
end

# source://dry-types//lib/dry/types/inflector.rb#7
Dry::Types::Inflector = T.let(T.unsafe(nil), Dry::Inflector)

# source://dry-types//lib/dry/types/intersection.rb#12
class Dry::Types::Intersection
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition

  # source://dry-types//lib/dry/types/intersection.rb#33
  def call_safe(input, &block); end

  # source://dry-types//lib/dry/types/intersection.rb#24
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/intersection.rb#55
  def primitive?(value); end

  # source://dry-types//lib/dry/types/intersection.rb#40
  def try(input); end

  private

  # source://dry-types//lib/dry/types/intersection.rb#94
  def merge_results(left_result, right_result); end

  # source://dry-types//lib/dry/types/intersection.rb#76
  def try_side(side, input); end

  # source://dry-types//lib/dry/types/intersection.rb#62
  def try_sides(input, &block); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#36
    def ast_type; end

    # source://dry-types//lib/dry/types/composition.rb#37
    def composition_name; end

    # source://dry-types//lib/dry/types/intersection.rb#15
    def operator; end
  end
end

# source://dry-types//lib/dry/types/intersection.rb#0
class Dry::Types::Intersection::Constrained < ::Dry::Types::Intersection
  include ::Dry::Types::Composition::Constrained
end

# source://dry-types//lib/dry/types/core.rb#6
Dry::Types::KERNEL_COERCIBLE = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/lax.rb#8
class Dry::Types::Lax
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # source://dry-types//lib/dry/types/lax.rb#22
  def [](input); end

  # source://dry-types//lib/dry/types/lax.rb#22
  def call(input); end

  # source://dry-types//lib/dry/types/lax.rb#22
  def call_safe(input); end

  # source://dry-types//lib/dry/types/lax.rb#22
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/lax.rb#52
  def lax; end

  # source://dry-types//lib/dry/types/lax.rb#45
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/lax.rb#38
  def try(input, &block); end

  private

  # source://dry-types//lib/dry/types/lax.rb#63
  def decorate?(response); end
end

# source://dry-types//lib/dry/types/core.rb#16
Dry::Types::METHOD_COERCIBLE = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/core.rb#21
Dry::Types::METHOD_COERCIBLE_METHODS = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/map.rb#25
class Dry::Types::Map < ::Dry::Types::Nominal
  # source://dry-types//lib/dry/types/map.rb#26
  def initialize(primitive, key_type: T.unsafe(nil), value_type: T.unsafe(nil), meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/map.rb#67
  def call_safe(hash); end

  # source://dry-types//lib/dry/types/map.rb#56
  def call_unsafe(hash); end

  # source://dry-types//lib/dry/types/map.rb#98
  def constrained?; end

  # source://dry-types//lib/dry/types/map.rb#33
  def key_type; end

  # source://dry-types//lib/dry/types/map.rb#47
  def name; end

  # source://dry-types//lib/dry/types/map.rb#88
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/map.rb#76
  def try(hash); end

  # source://dry-types//lib/dry/types/map.rb#40
  def value_type; end

  private

  # source://dry-types//lib/dry/types/map.rb#107
  def coerce(input); end
end

# source://dry-types//lib/dry/types/errors.rb#89
class Dry::Types::MapError < ::Dry::Types::CoercionError; end

# source://dry-types//lib/dry/types/meta.rb#8
module Dry::Types::Meta
  # source://dry-types//lib/dry/types/meta.rb#9
  def initialize(*args, meta: T.unsafe(nil), **options); end

  # source://dry-types//lib/dry/types/meta.rb#31
  def meta(data = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/meta.rb#46
  def pristine; end

  # source://dry-types//lib/dry/types/meta.rb#19
  def with(**options); end
end

# source://dry-types//lib/dry/types/errors.rb#94
class Dry::Types::MissingKeyError < ::Dry::Types::SchemaKeyError
  # source://dry-types//lib/dry/types/errors.rb#99
  def initialize(key); end

  # source://dry-types//lib/dry/types/errors.rb#96
  def key; end
end

# source://dry-types//lib/dry/types/module.rb#19
class Dry::Types::Module < ::Module
  # source://dry-types//lib/dry/types/module.rb#20
  def initialize(registry, *args, **kwargs); end

  # source://dry-types//lib/dry/types/module.rb#76
  def registry_tree; end

  # source://dry-types//lib/dry/types/module.rb#43
  def type_constants(*namespaces, default: T.unsafe(nil), **aliases); end

  private

  # source://dry-types//lib/dry/types/module.rb#91
  def check_parameters(*namespaces, default: T.unsafe(nil), **aliases); end

  # source://dry-types//lib/dry/types/module.rb#111
  def define_constants(constants, mod = T.unsafe(nil)); end
end

# source://dry-types//lib/dry/types/errors.rb#48
class Dry::Types::MultipleError < ::Dry::Types::CoercionError
  # source://dry-types//lib/dry/types/errors.rb#53
  def initialize(errors); end

  # source://dry-types//lib/dry/types/errors.rb#50
  def errors; end

  # source://dry-types//lib/dry/types/errors.rb#59
  def message; end

  # source://dry-types//lib/dry/types/errors.rb#64
  def meta; end
end

# source://dry-types//lib/dry/types/core.rb#26
Dry::Types::NON_COERCIBLE = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/core.rb#44
Dry::Types::NON_NIL = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/nominal.rb#10
class Dry::Types::Nominal
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # source://dry-types//lib/dry/types/nominal.rb#42
  def initialize(primitive, **options); end

  # source://dry-types//lib/dry/types/nominal.rb#90
  def call_safe(input); end

  # source://dry-types//lib/dry/types/nominal.rb#81
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/nominal.rb#139
  def coerce(input, &_block); end

  # source://dry-types//lib/dry/types/nominal.rb#65
  def constrained?; end

  # source://dry-types//lib/dry/types/nominal.rb#58
  def default?; end

  # source://dry-types//lib/dry/types/nominal.rb#121
  def failure(input, error); end

  # source://dry-types//lib/dry/types/nominal.rb#181
  def lax; end

  # source://dry-types//lib/dry/types/nominal.rb#51
  def name; end

  # source://dry-types//lib/dry/types/nominal.rb#72
  def optional?; end

  # source://dry-types//lib/dry/types/nominal.rb#19
  def primitive; end

  # source://dry-types//lib/dry/types/nominal.rb#134
  def primitive?(value); end

  # source://dry-types//lib/dry/types/nominal.rb#112
  def success(input); end

  # source://dry-types//lib/dry/types/nominal.rb#172
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/nominal.rb#190
  def to_proc; end

  # source://dry-types//lib/dry/types/nominal.rb#103
  def try(input); end

  # source://dry-types//lib/dry/types/nominal.rb#150
  def try_coerce(input); end

  class << self
    # source://dry-types//lib/dry/types/nominal.rb#26
    def [](primitive); end
  end
end

# source://dry-types//lib/dry/types/nominal.rb#36
Dry::Types::Nominal::ALWAYS = T.let(T.unsafe(nil), Proc)

# source://dry-types//lib/dry/types/options.rb#8
module Dry::Types::Options
  # source://dry-types//lib/dry/types/options.rb#15
  def initialize(*args, **options); end

  # source://dry-types//lib/dry/types/options.rb#10
  def options; end

  # source://dry-types//lib/dry/types/options.rb#25
  def with(**new_options); end
end

# source://dry-types//lib/dry/types/printer.rb#296
Dry::Types::PRINTER = T.let(T.unsafe(nil), Dry::Types::Printer)

# source://dry-types//lib/dry/types/predicate_inferrer.rb#8
class Dry::Types::PredicateInferrer
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#214
  def initialize(registry = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#224
  def [](type); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#211
  def compiler; end
end

# source://dry-types//lib/dry/types/predicate_inferrer.rb#31
Dry::Types::PredicateInferrer::ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-types//lib/dry/types/predicate_inferrer.rb#38
class Dry::Types::PredicateInferrer::Compiler
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#49
  def initialize(registry); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#54
  def infer_predicate(type); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#46
  def registry; end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#89
  def visit(node); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#165
  def visit_and(node); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#160
  def visit_any(_); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#113
  def visit_array(_); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#148
  def visit_constrained(node); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#123
  def visit_constructor(node); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#129
  def visit_enum(node); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#107
  def visit_hash(_); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#118
  def visit_lax(node); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#189
  def visit_map(_node); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#95
  def visit_nominal(node); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#171
  def visit_predicate(node); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#107
  def visit_schema(_); end

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#135
  def visit_sum(node); end

  private

  # source://dry-types//lib/dry/types/predicate_inferrer.rb#196
  def merge_predicates(nodes); end
end

# source://dry-types//lib/dry/types/predicate_inferrer.rb#29
Dry::Types::PredicateInferrer::HASH = T.let(T.unsafe(nil), Array)

# source://dry-types//lib/dry/types/predicate_inferrer.rb#33
Dry::Types::PredicateInferrer::NIL = T.let(T.unsafe(nil), Array)

# source://dry-types//lib/dry/types/predicate_inferrer.rb#25
Dry::Types::PredicateInferrer::REDUCED_TYPES = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/predicate_inferrer.rb#11
Dry::Types::PredicateInferrer::TYPE_TO_PREDICATE = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/predicate_registry.rb#8
class Dry::Types::PredicateRegistry
  # source://dry-types//lib/dry/types/predicate_registry.rb#19
  def initialize(predicates = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/predicate_registry.rb#29
  def [](name); end

  # source://dry-types//lib/dry/types/predicate_registry.rb#13
  def has_predicate; end

  # source://dry-types//lib/dry/types/predicate_registry.rb#24
  def key?(name); end

  # source://dry-types//lib/dry/types/predicate_registry.rb#10
  def predicates; end
end

# source://dry-types//lib/dry/types/predicate_registry.rb#15
Dry::Types::PredicateRegistry::KERNEL_RESPOND_TO = T.let(T.unsafe(nil), UnboundMethod)

# source://dry-types//lib/dry/types/primitive_inferrer.rb#8
class Dry::Types::PrimitiveInferrer
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#79
  def initialize; end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#88
  def [](type); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#76
  def compiler; end
end

# source://dry-types//lib/dry/types/primitive_inferrer.rb#14
class Dry::Types::PrimitiveInferrer::Compiler
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#16
  def visit(node); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#69
  def visit_any(_); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#34
  def visit_array(_); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#63
  def visit_constrained(node); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#44
  def visit_constructor(node); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#50
  def visit_enum(node); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#28
  def visit_hash(_); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#39
  def visit_lax(node); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#22
  def visit_nominal(node); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#28
  def visit_schema(_); end

  # source://dry-types//lib/dry/types/primitive_inferrer.rb#56
  def visit_sum(node); end
end

# source://dry-types//lib/dry/types/printable.rb#6
module Dry::Types::Printable
  # source://dry-types//lib/dry/types/printable.rb#10
  def inspect; end

  # source://dry-types//lib/dry/types/printable.rb#10
  def to_s; end
end

# source://dry-types//lib/dry/types/printer/composition.rb#6
class Dry::Types::Printer
  # source://dry-types//lib/dry/types/printer.rb#38
  def initialize; end

  # source://dry-types//lib/dry/types/printer.rb#43
  def call(type); end

  # source://dry-types//lib/dry/types/printer.rb#49
  def visit(type, &block); end

  # source://dry-types//lib/dry/types/printer.rb#62
  def visit_any(_); end

  # source://dry-types//lib/dry/types/printer.rb#66
  def visit_array(type); end

  # source://dry-types//lib/dry/types/printer.rb#72
  def visit_array_member(array); end

  # source://dry-types//lib/dry/types/printer.rb#155
  def visit_callable(callable); end

  # source://dry-types//lib/dry/types/printer.rb#104
  def visit_composition(composition, &block); end

  # source://dry-types//lib/dry/types/printer.rb#93
  def visit_constrained(constrained); end

  # source://dry-types//lib/dry/types/printer.rb#80
  def visit_constructor(constructor); end

  # source://dry-types//lib/dry/types/printer.rb#129
  def visit_default(default); end

  # source://dry-types//lib/dry/types/printer.rb#110
  def visit_enum(enum); end

  # source://dry-types//lib/dry/types/printer.rb#253
  def visit_hash(hash); end

  # source://dry-types//lib/dry/types/printer.rb#243
  def visit_key(key); end

  # source://dry-types//lib/dry/types/printer.rb#149
  def visit_lax(lax); end

  # source://dry-types//lib/dry/types/printer.rb#229
  def visit_map(map); end

  # source://dry-types//lib/dry/types/printer.rb#143
  def visit_nominal(type); end

  # source://dry-types//lib/dry/types/printer.rb#272
  def visit_options(options, meta = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/printer.rb#190
  def visit_schema(schema); end
end

# source://dry-types//lib/dry/types/printer/composition.rb#8
class Dry::Types::Printer::Composition
  # source://dry-types//lib/dry/types/printer/composition.rb#9
  def initialize(printer, composition_class); end

  # source://dry-types//lib/dry/types/printer/composition.rb#15
  def visit(composition); end

  private

  # source://dry-types//lib/dry/types/printer/composition.rb#33
  def visit_constructor(type, &block); end

  # source://dry-types//lib/dry/types/printer/composition.rb#25
  def visit_constructors(composition); end
end

# source://dry-types//lib/dry/types/printer.rb#11
Dry::Types::Printer::MAPPING = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/result.rb#8
class Dry::Types::Result
  include ::Dry::Core::Equalizer::Methods

  # source://dry-types//lib/dry/types/result.rb#17
  def initialize(input); end

  # source://dry-types//lib/dry/types/result.rb#12
  def input; end
end

# source://dry-types//lib/dry/types/result.rb#43
class Dry::Types::Result::Failure < ::Dry::Types::Result
  # source://dry-types//lib/dry/types/result.rb#54
  def initialize(input, error); end

  # source://dry-types//lib/dry/types/result.rb#47
  def error; end

  # source://dry-types//lib/dry/types/result.rb#76
  def failure?; end

  # source://dry-types//lib/dry/types/result.rb#69
  def success?; end

  # source://dry-types//lib/dry/types/result.rb#62
  def to_s; end
end

# source://dry-types//lib/dry/types/result.rb#24
class Dry::Types::Result::Success < ::Dry::Types::Result
  # source://dry-types//lib/dry/types/result.rb#35
  def failure?; end

  # source://dry-types//lib/dry/types/result.rb#28
  def success?; end
end

Dry::Types::Safe = Dry::Types::Lax

# source://dry-types//lib/dry/types/schema.rb#19
class Dry::Types::Schema < ::Dry::Types::Hash
  include ::Enumerable

  # source://dry-types//lib/dry/types/schema.rb#41
  def initialize(_primitive, **options); end

  # source://dry-types//lib/dry/types/schema.rb#80
  def apply(hash, options = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/schema.rb#68
  def call_safe(hash, options = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/schema.rb#59
  def call_unsafe(hash, options = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/schema.rb#298
  def clear; end

  # source://dry-types//lib/dry/types/schema.rb#270
  def constrained?; end

  # source://dry-types//lib/dry/types/schema.rb#229
  def each(&block); end

  # source://dry-types//lib/dry/types/schema.rb#259
  def key(name, fallback = T.unsafe(nil), &block); end

  # source://dry-types//lib/dry/types/schema.rb#240
  def key?(name); end

  # source://dry-types//lib/dry/types/schema.rb#26
  def keys; end

  # source://dry-types//lib/dry/types/schema.rb#277
  def lax; end

  # source://dry-types//lib/dry/types/schema.rb#289
  def merge(other); end

  # source://dry-types//lib/dry/types/schema.rb#29
  def name_key_map; end

  # source://dry-types//lib/dry/types/schema.rb#213
  def schema(keys_or_map); end

  # source://dry-types//lib/dry/types/schema.rb#172
  def strict(strict = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/schema.rb#163
  def strict?; end

  # source://dry-types//lib/dry/types/schema.rb#149
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/schema.rb#32
  def transform_key; end

  # source://dry-types//lib/dry/types/schema.rb#198
  def transform_keys?; end

  # source://dry-types//lib/dry/types/schema.rb#95
  def try(input); end

  # source://dry-types//lib/dry/types/schema.rb#184
  def with_key_transform(proc = T.unsafe(nil), &block); end

  private

  # source://dry-types//lib/dry/types/schema.rb#309
  def merge_keys(*keys); end

  # source://dry-types//lib/dry/types/schema.rb#405
  def missing_key(key); end

  # source://dry-types//lib/dry/types/schema.rb#373
  def resolve_missing_keys(hash, options); end

  # source://dry-types//lib/dry/types/schema.rb#351
  def resolve_safe(hash, options = T.unsafe(nil), &block); end

  # source://dry-types//lib/dry/types/schema.rb#321
  def resolve_unsafe(hash, options = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/schema.rb#397
  def unexpected_keys(hash_keys); end
end

# source://dry-types//lib/dry/types/schema/key.rb#14
class Dry::Types::Schema::Key
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  extend ::Dry::Core::Deprecations::Interface

  # source://dry-types//lib/dry/types/schema/key.rb#26
  def initialize(type, name, required: T.unsafe(nil), **options); end

  # source://dry-types//lib/dry/types/schema/key.rb#40
  def call_safe(input, &block); end

  # source://dry-types//lib/dry/types/schema/key.rb#45
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/schema/key.rb#99
  def lax; end

  # source://dry-types//lib/dry/types/schema/key.rb#131
  def meta(data = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/schema/key.rb#23
  def name; end

  # source://dry-types//lib/dry/types/schema/key.rb#90
  def omittable; end

  # source://dry-types//lib/dry/types/schema/key.rb#108
  def optional; end

  # source://dry-types//lib/dry/types/schema/key.rb#77
  def required(required = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/schema/key.rb#61
  def required?; end

  # source://dry-types//lib/dry/types/schema/key.rb#117
  def to_ast(meta: T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/schema/key.rb#52
  def try(input, &block); end

  private

  # source://dry-types//lib/dry/types/schema/key.rb#147
  def decorate?(response); end
end

# source://dry-types//lib/dry/types/schema.rb#20
Dry::Types::Schema::NO_TRANSFORM = T.let(T.unsafe(nil), String)

# source://dry-types//lib/dry/types/schema.rb#21
Dry::Types::Schema::SYMBOLIZE_KEY = T.let(T.unsafe(nil), String)

# source://dry-types//lib/dry/types/errors.rb#69
class Dry::Types::SchemaError < ::Dry::Types::CoercionError
  # source://dry-types//lib/dry/types/errors.rb#79
  def initialize(key, value, result); end

  # source://dry-types//lib/dry/types/errors.rb#71
  def key; end

  # source://dry-types//lib/dry/types/errors.rb#74
  def value; end
end

# source://dry-types//lib/dry/types/errors.rb#91
class Dry::Types::SchemaKeyError < ::Dry::Types::CoercionError; end

# source://dry-types//lib/dry/types/sum.rb#8
class Dry::Types::Sum
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition

  # source://dry-types//lib/dry/types/sum.rb#36
  def call_safe(input, &block); end

  # source://dry-types//lib/dry/types/sum.rb#27
  def call_unsafe(input); end

  # source://dry-types//lib/dry/types/sum.rb#87
  def constrained(options); end

  # source://dry-types//lib/dry/types/sum.rb#70
  def meta(data = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/sum.rb#18
  def optional?; end

  # source://dry-types//lib/dry/types/sum.rb#60
  def primitive?(value); end

  # source://dry-types//lib/dry/types/sum.rb#43
  def try(input); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#36
    def ast_type; end

    # source://dry-types//lib/dry/types/composition.rb#37
    def composition_name; end

    # source://dry-types//lib/dry/types/sum.rb#11
    def operator; end
  end
end

# source://dry-types//lib/dry/types/sum.rb#0
class Dry::Types::Sum::Constrained < ::Dry::Types::Sum
  include ::Dry::Types::Composition::Constrained
end

# source://dry-types//lib/dry/types.rb#31
Dry::Types::TYPE_SPEC_REGEX = T.let(T.unsafe(nil), Regexp)

# source://dry-types//lib/dry/types/type.rb#8
module Dry::Types::Type
  extend ::Dry::Core::Deprecations::Interface

  # source://dry-types//lib/dry/types/type.rb#18
  def ===(input = T.unsafe(nil)); end

  # source://dry-types//lib/dry/types/type.rb#43
  def [](input = T.unsafe(nil), &block); end

  # source://dry-types//lib/dry/types/type.rb#43
  def call(input = T.unsafe(nil), &block); end

  # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#168
  def safe(*args, &block); end

  # source://dry-types//lib/dry/types/type.rb#18
  def valid?(input = T.unsafe(nil)); end
end

# source://dry-types//lib/dry/types/errors.rb#105
class Dry::Types::UnknownKeysError < ::Dry::Types::SchemaKeyError
  # source://dry-types//lib/dry/types/errors.rb#110
  def initialize(keys); end

  # source://dry-types//lib/dry/types/errors.rb#107
  def keys; end
end

# source://dry-types//lib/dry/types/version.rb#5
Dry::Types::VERSION = T.let(T.unsafe(nil), String)
