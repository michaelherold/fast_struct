# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `csv` gem.
# Please instead update this file by running `bin/tapioca gem csv`.

class Array
  include ::Enumerable

  # source://csv//csv/core_ext/array.rb#6
  def to_csv(**options); end
end

class CSV
  include ::Enumerable
  extend ::Forwardable

  # source://csv//csv.rb#1905
  def initialize(data, col_sep: T.unsafe(nil), row_sep: T.unsafe(nil), quote_char: T.unsafe(nil), field_size_limit: T.unsafe(nil), max_field_size: T.unsafe(nil), converters: T.unsafe(nil), unconverted_fields: T.unsafe(nil), headers: T.unsafe(nil), return_headers: T.unsafe(nil), write_headers: T.unsafe(nil), header_converters: T.unsafe(nil), skip_blanks: T.unsafe(nil), force_quotes: T.unsafe(nil), skip_lines: T.unsafe(nil), liberal_parsing: T.unsafe(nil), internal_encoding: T.unsafe(nil), external_encoding: T.unsafe(nil), encoding: T.unsafe(nil), nil_value: T.unsafe(nil), empty_value: T.unsafe(nil), strip: T.unsafe(nil), quote_empty: T.unsafe(nil), write_converters: T.unsafe(nil), write_nil_value: T.unsafe(nil), write_empty_value: T.unsafe(nil)); end

  # source://csv//csv.rb#2372
  def <<(row); end

  # source://csv//csv.rb#2372
  def add_row(row); end

  # source://csv//csv.rb#2261
  def binmode?; end

  # source://csv//csv.rb#2009
  def col_sep; end

  # source://csv//csv.rb#2443
  def convert(name = T.unsafe(nil), &converter); end

  # source://csv//csv.rb#2082
  def converters; end

  # source://csv//csv.rb#2554
  def each(&block); end

  # source://csv//csv.rb#2192
  def encoding; end

  # source://csv//csv.rb#2297
  def eof; end

  # source://csv//csv.rb#2297
  def eof?; end

  # source://csv//csv.rb#2041
  def field_size_limit; end

  # source://csv//csv.rb#2269
  def flock(*args); end

  # source://csv//csv.rb#2172
  def force_quotes?; end

  # source://csv//csv.rb#2668
  def gets; end

  # source://csv//csv.rb#2509
  def header_convert(name = T.unsafe(nil), &converter); end

  # source://csv//csv.rb#2148
  def header_converters; end

  # source://csv//csv.rb#2631
  def header_row?; end

  # source://csv//csv.rb#2106
  def headers; end

  # source://csv//csv.rb#2690
  def inspect; end

  # source://csv//csv.rb#2274
  def ioctl(*args); end

  # source://csv//csv.rb#2182
  def liberal_parsing?; end

  # source://csv//csv.rb#2247
  def line; end

  # source://csv//csv.rb#2223
  def lineno; end

  # source://csv//csv.rb#2053
  def max_field_size; end

  # source://csv//csv.rb#2279
  def path; end

  # source://csv//csv.rb#2372
  def puts(row); end

  # source://csv//csv.rb#2029
  def quote_char; end

  # source://csv//csv.rb#2595
  def read; end

  # source://csv//csv.rb#2668
  def readline; end

  # source://csv//csv.rb#2595
  def readlines; end

  # source://csv//csv.rb#2124
  def return_headers?; end

  # source://csv//csv.rb#2312
  def rewind; end

  # source://csv//csv.rb#2019
  def row_sep; end

  # source://csv//csv.rb#2668
  def shift; end

  # source://csv//csv.rb#2161
  def skip_blanks?; end

  # source://csv//csv.rb#2063
  def skip_lines; end

  # source://csv//csv.rb#2283
  def stat(*args); end

  # source://csv//csv.rb#2288
  def to_i; end

  # source://csv//csv.rb#2293
  def to_io; end

  # source://csv//csv.rb#2096
  def unconverted_fields?; end

  # source://csv//csv.rb#2134
  def write_headers?; end

  private

  # source://csv//csv.rb#2822
  def build_fields_converter(initial_converters, options); end

  # source://csv//csv.rb#2804
  def build_header_fields_converter; end

  # source://csv//csv.rb#2792
  def build_parser_fields_converter; end

  # source://csv//csv.rb#2817
  def build_writer_fields_converter; end

  # source://csv//csv.rb#2767
  def convert_fields(fields, headers = T.unsafe(nil)); end

  # source://csv//csv.rb#2730
  def determine_encoding(encoding, internal_encoding); end

  # source://csv//csv.rb#2800
  def header_fields_converter; end

  # source://csv//csv.rb#2745
  def normalize_converters(converters); end

  # source://csv//csv.rb#2830
  def parser; end

  # source://csv//csv.rb#2839
  def parser_enumerator; end

  # source://csv//csv.rb#2788
  def parser_fields_converter; end

  # source://csv//csv.rb#2834
  def parser_options; end

  # source://csv//csv.rb#2778
  def raw_encoding; end

  # source://csv//csv.rb#2843
  def writer; end

  # source://csv//csv.rb#2813
  def writer_fields_converter; end

  # source://csv//csv.rb#2847
  def writer_options; end

  class << self
    # source://csv//csv.rb#1202
    def filter(input = T.unsafe(nil), output = T.unsafe(nil), **options); end

    # source://csv//csv.rb#1332
    def foreach(path, mode = T.unsafe(nil), **options, &block); end

    # source://csv//csv.rb#1398
    def generate(str = T.unsafe(nil), **options); end

    # source://csv//csv.rb#1446
    def generate_line(row, **options); end

    # source://csv//csv.rb#1501
    def generate_lines(rows, **options); end

    # source://csv//csv.rb#1006
    def instance(data = T.unsafe(nil), **options); end

    # source://csv//csv.rb#1581
    def open(filename, mode = T.unsafe(nil), **options); end

    # source://csv//csv.rb#1732
    def parse(str, **options, &block); end

    # source://csv//csv.rb#1805
    def parse_line(line, **options); end

    # source://csv//csv.rb#1829
    def read(path, **options); end

    # source://csv//csv.rb#1837
    def readlines(path, **options); end

    # source://csv//csv.rb#1856
    def table(path, **options); end
  end
end

# source://csv//csv.rb#883
CSV::ConverterEncoding = T.let(T.unsafe(nil), Encoding)

# source://csv//csv.rb#891
CSV::Converters = T.let(T.unsafe(nil), Hash)

# source://csv//csv.rb#872
CSV::DateMatcher = T.let(T.unsafe(nil), Regexp)

# source://csv//csv.rb#875
CSV::DateTimeMatcher = T.let(T.unsafe(nil), Regexp)

class CSV::FieldsConverter
  include ::Enumerable

  # source://csv//csv/fields_converter.rb#13
  def initialize(options = T.unsafe(nil)); end

  # source://csv//csv/fields_converter.rb#23
  def add_converter(name = T.unsafe(nil), &converter); end

  # source://csv//csv/fields_converter.rb#47
  def convert(fields, headers, lineno, quoted_fields); end

  # source://csv//csv/fields_converter.rb#39
  def each(&block); end

  # source://csv//csv/fields_converter.rb#43
  def empty?; end

  private

  # source://csv//csv/fields_converter.rb#85
  def builtin_converters; end

  # source://csv//csv/fields_converter.rb#80
  def need_convert?; end

  # source://csv//csv/fields_converter.rb#76
  def need_static_convert?; end
end

# source://csv//csv.rb#924
CSV::HeaderConverters = T.let(T.unsafe(nil), Hash)

module CSV::InputRecordSeparator
  class << self
    # source://csv//csv/input_record_separator.rb#8
    def value; end
  end
end

class CSV::InvalidEncodingError < ::CSV::MalformedCSVError
  # source://csv//csv.rb#852
  def initialize(encoding, line_number); end

  # source://csv//csv.rb#851
  def encoding; end
end

class CSV::MalformedCSVError < ::RuntimeError
  # source://csv//csv.rb#843
  def initialize(message, line_number); end

  # source://csv//csv.rb#841
  def line_number; end

  # source://csv//csv.rb#841
  def lineno; end
end

class CSV::Parser
  # source://csv//csv/parser.rb#326
  def initialize(input, options); end

  # source://csv//csv/parser.rb#334
  def column_separator; end

  # source://csv//csv/parser.rb#346
  def field_size_limit; end

  # source://csv//csv/parser.rb#366
  def header_row?; end

  # source://csv//csv/parser.rb#362
  def headers; end

  # source://csv//csv/parser.rb#378
  def liberal_parsing?; end

  # source://csv//csv/parser.rb#386
  def line; end

  # source://csv//csv/parser.rb#382
  def lineno; end

  # source://csv//csv/parser.rb#350
  def max_field_size; end

  # source://csv//csv/parser.rb#390
  def parse(&block); end

  # source://csv//csv/parser.rb#342
  def quote_character; end

  # source://csv//csv/parser.rb#370
  def return_headers?; end

  # source://csv//csv/parser.rb#338
  def row_separator; end

  # source://csv//csv/parser.rb#374
  def skip_blanks?; end

  # source://csv//csv/parser.rb#354
  def skip_lines; end

  # source://csv//csv/parser.rb#358
  def unconverted_fields?; end

  # source://csv//csv/parser.rb#431
  def use_headers?; end

  private

  # source://csv//csv/parser.rb#1280
  def add_unconverted_fields(row, fields); end

  # source://csv//csv/parser.rb#794
  def adjust_headers(headers, quoted_fields); end

  # source://csv//csv/parser.rb#862
  def build_scanner; end

  # source://csv//csv/parser.rb#716
  def detect_row_separator(sample, cr, lf); end

  # source://csv//csv/parser.rb#1251
  def emit_row(row, quoted_fields, &block); end

  # source://csv//csv/parser.rb#1236
  def ignore_broken_line; end

  # source://csv//csv/parser.rb#746
  def last_line; end

  # source://csv//csv/parser.rb#804
  def may_quoted?; end

  # source://csv//csv/parser.rb#1191
  def parse_column_end; end

  # source://csv//csv/parser.rb#1091
  def parse_column_value; end

  # source://csv//csv/parser.rb#780
  def parse_headers(row); end

  # source://csv//csv/parser.rb#929
  def parse_no_quote(&block); end

  # source://csv//csv/parser.rb#960
  def parse_quotable_loose(&block); end

  # source://csv//csv/parser.rb#1021
  def parse_quotable_robust(&block); end

  # source://csv//csv/parser.rb#1149
  def parse_quoted_column_value; end

  # source://csv//csv/parser.rb#1205
  def parse_row_end; end

  # source://csv//csv/parser.rb#1121
  def parse_unquoted_column_value; end

  # source://csv//csv/parser.rb#437
  def prepare; end

  # source://csv//csv/parser.rb#494
  def prepare_backslash; end

  # source://csv//csv/parser.rb#754
  def prepare_header; end

  # source://csv//csv/parser.rb#740
  def prepare_line; end

  # source://csv//csv/parser.rb#800
  def prepare_parser; end

  # source://csv//csv/parser.rb#478
  def prepare_quote_character; end

  # source://csv//csv/parser.rb#636
  def prepare_quoted; end

  # source://csv//csv/parser.rb#568
  def prepare_separators; end

  # source://csv//csv/parser.rb#509
  def prepare_skip_lines; end

  # source://csv//csv/parser.rb#526
  def prepare_strip; end

  # source://csv//csv/parser.rb#663
  def prepare_unquoted; end

  # source://csv//csv/parser.rb#452
  def prepare_variable; end

  # source://csv//csv/parser.rb#676
  def resolve_row_separator(separator); end

  # source://csv//csv/parser.rb#909
  def skip_line?(line); end

  # source://csv//csv/parser.rb#892
  def skip_needless_lines; end

  # source://csv//csv/parser.rb#1242
  def start_row; end

  # source://csv//csv/parser.rb#1218
  def strip_value(value); end

  # source://csv//csv/parser.rb#921
  def validate_field_size(field); end

  # source://csv//csv/parser.rb#618
  def validate_strip_and_col_sep_options; end
end

class CSV::Parser::InputsScanner
  # source://csv//csv/parser.rb#87
  def initialize(inputs, encoding, row_separator, chunk_size: T.unsafe(nil)); end

  # source://csv//csv/parser.rb#248
  def check(pattern); end

  # source://csv//csv/parser.rb#97
  def each_line(row_separator); end

  # source://csv//csv/parser.rb#170
  def eos?; end

  # source://csv//csv/parser.rb#197
  def keep_back; end

  # source://csv//csv/parser.rb#227
  def keep_drop; end

  # source://csv//csv/parser.rb#181
  def keep_end; end

  # source://csv//csv/parser.rb#174
  def keep_start; end

  # source://csv//csv/parser.rb#244
  def rest; end

  # source://csv//csv/parser.rb#143
  def scan(pattern); end

  # source://csv//csv/parser.rb#154
  def scan_all(pattern); end

  private

  # source://csv//csv/parser.rb#257
  def adjust_last_keep; end

  # source://csv//csv/parser.rb#285
  def read_chunk; end

  # source://csv//csv/parser.rb#253
  def trace(*args); end
end

class CSV::Parser::InvalidEncoding < ::StandardError; end

# source://csv//csv/parser.rb#836
CSV::Parser::SCANNER_TEST = T.let(T.unsafe(nil), FalseClass)

# source://csv//csv/parser.rb#565
CSV::Parser::STRING_SCANNER_SCAN_ACCEPT_STRING = T.let(T.unsafe(nil), TrueClass)

class CSV::Parser::Scanner < ::StringScanner
  # source://csv//csv/parser.rb#42
  def initialize(*args); end

  # source://csv//csv/parser.rb#47
  def each_line(row_separator); end

  # source://csv//csv/parser.rb#65
  def keep_back; end

  # source://csv//csv/parser.rb#69
  def keep_drop; end

  # source://csv//csv/parser.rb#60
  def keep_end; end

  # source://csv//csv/parser.rb#56
  def keep_start; end

  def scan_all(_arg0); end
end

class CSV::Parser::UnexpectedError < ::StandardError; end

class CSV::Parser::UnoptimizedStringIO
  # source://csv//csv/parser.rb#819
  def initialize(string); end

  # source://csv//csv/parser.rb#827
  def each_line(*args, &block); end

  # source://csv//csv/parser.rb#831
  def eof?; end

  # source://csv//csv/parser.rb#823
  def gets(*args); end
end

class CSV::Row
  include ::Enumerable
  extend ::Forwardable

  # source://csv//csv/row.rb#105
  def initialize(headers, fields, header_row = T.unsafe(nil)); end

  # source://csv//csv/row.rb#389
  def <<(arg); end

  # source://csv//csv/row.rb#633
  def ==(other); end

  # source://csv//csv/row.rb#203
  def [](header_or_index, minimum_index = T.unsafe(nil)); end

  # source://csv//csv/row.rb#339
  def []=(*args); end

  # source://csv//csv/row.rb#682
  def deconstruct; end

  # source://csv//csv/row.rb#667
  def deconstruct_keys(keys); end

  # source://csv//csv/row.rb#451
  def delete(header_or_index, minimum_index = T.unsafe(nil)); end

  # source://csv//csv/row.rb#476
  def delete_if(&block); end

  # source://csv//csv/row.rb#715
  def dig(index_or_header, *indexes); end

  # source://csv//csv/row.rb#610
  def each(&block); end

  # source://csv//csv/row.rb#610
  def each_pair(&block); end

  # source://csv//csv/row.rb#258
  def fetch(header, *varargs); end

  # source://csv//csv/row.rb#203
  def field(header_or_index, minimum_index = T.unsafe(nil)); end

  # source://csv//csv/row.rb#589
  def field?(data); end

  # source://csv//csv/row.rb#148
  def field_row?; end

  # source://csv//csv/row.rb#530
  def fields(*headers_and_or_indices); end

  # source://csv//csv/row.rb#279
  def has_key?(header); end

  # source://csv//csv/row.rb#279
  def header?(header); end

  # source://csv//csv/row.rb#140
  def header_row?; end

  # source://csv//csv/row.rb#160
  def headers; end

  # source://csv//csv/row.rb#279
  def include?(header); end

  # source://csv//csv/row.rb#573
  def index(header, minimum_index = T.unsafe(nil)); end

  # source://csv//csv/row.rb#740
  def inspect; end

  # source://csv//csv/row.rb#279
  def key?(header); end

  # source://csv//csv/row.rb#279
  def member?(header); end

  # source://csv//csv/row.rb#410
  def push(*args); end

  # source://csv//csv/row.rb#694
  def to_csv(**options); end

  # source://csv//csv/row.rb#653
  def to_h; end

  # source://csv//csv/row.rb#653
  def to_hash; end

  # source://csv//csv/row.rb#694
  def to_s(**options); end

  # source://csv//csv/row.rb#530
  def values_at(*headers_and_or_indices); end

  protected

  # source://csv//csv/row.rb#118
  def row; end

  private

  # source://csv//csv/row.rb#130
  def initialize_copy(other); end
end

class CSV::Table
  include ::Enumerable
  extend ::Forwardable

  # source://csv//csv/table.rb#199
  def initialize(array_of_rows, headers: T.unsafe(nil)); end

  # source://csv//csv/table.rb#762
  def <<(row_or_array); end

  # source://csv//csv/table.rb#965
  def ==(other); end

  # source://csv//csv/table.rb#514
  def [](index_or_header); end

  # source://csv//csv/table.rb#649
  def []=(index_or_header, value); end

  # source://csv//csv/table.rb#242
  def by_col; end

  # source://csv//csv/table.rb#257
  def by_col!; end

  # source://csv//csv/table.rb#280
  def by_col_or_row; end

  # source://csv//csv/table.rb#295
  def by_col_or_row!; end

  # source://csv//csv/table.rb#318
  def by_row; end

  # source://csv//csv/table.rb#333
  def by_row!; end

  # source://csv//csv/table.rb#834
  def delete(*indexes_or_headers); end

  # source://csv//csv/table.rb#887
  def delete_if(&block); end

  # source://csv//csv/table.rb#1021
  def dig(index_or_header, *index_or_headers); end

  # source://csv//csv/table.rb#930
  def each(&block); end

  # source://csv//csv/table.rb#360
  def headers; end

  # source://csv//csv/table.rb#1048
  def inspect; end

  # source://csv//csv/table.rb#214
  def mode; end

  # source://csv//csv/table.rb#788
  def push(*rows); end

  # source://csv//csv/table.rb#978
  def to_a; end

  # source://csv//csv/table.rb#1004
  def to_csv(write_headers: T.unsafe(nil), limit: T.unsafe(nil), **options); end

  # source://csv//csv/table.rb#1004
  def to_s(write_headers: T.unsafe(nil), limit: T.unsafe(nil), **options); end

  # source://csv//csv/table.rb#734
  def values_at(*indices_or_headers); end

  protected

  # source://csv//csv/table.rb#217
  def table; end
end

class CSV::Writer
  # source://csv//csv/writer.rb#16
  def initialize(output, options); end

  # source://csv//csv/writer.rb#31
  def <<(row); end

  # source://csv//csv/writer.rb#14
  def headers; end

  # source://csv//csv/writer.rb#13
  def lineno; end

  # source://csv//csv/writer.rb#64
  def rewind; end

  private

  # source://csv//csv/writer.rb#70
  def prepare; end

  # source://csv//csv/writer.rb#106
  def prepare_force_quotes_fields(force_quotes); end

  # source://csv//csv/writer.rb#133
  def prepare_format; end

  # source://csv//csv/writer.rb#78
  def prepare_header; end

  # source://csv//csv/writer.rb#163
  def prepare_output; end

  # source://csv//csv/writer.rb#190
  def quote(field, i); end

  # source://csv//csv/writer.rb#181
  def quote_field(field); end
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  private

  # source://csv//csv.rb#2876
  def CSV(*args, **options, &block); end
end

class String
  include ::Comparable

  # source://csv//csv/core_ext/string.rb#6
  def parse_csv(**options); end
end
